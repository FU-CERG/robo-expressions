<project name="wf_digitaler_assistent_1" app="Snap! 6, https://snap.berkeley.edu" version="1"><notes></notes><thumbnail>data:image/png;base64,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</thumbnail><stage name="Stage" width="480" height="360" costume="0" color="255,255,255,1" tempo="60" threadsafe="false" penlog="false" volume="100" pan="0" lines="round" ternary="false" hyperops="true" codify="false" inheritance="true" sublistIDs="false" scheduled="false" id="1"><pentrails>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAFoCAYAAACPNyggAAAAAXNSR0IArs4c6QAADoVJREFUeF7t1cEJAAAIxDDdf2m3sJ+4wEEQuuMIECBAgACBd4F9XzRIgAABAgQIjAB7AgIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECByxcQFpoRMBzwAAAABJRU5ErkJggg==</pentrails><costumes><list struct="atomic" id="2"></list></costumes><sounds><list struct="atomic" id="3"></list></sounds><variables></variables><blocks></blocks><scripts></scripts><sprites><sprite name="Sprite" idx="1" x="3.7350604464238586" y="-4.897040465168516" heading="90" scale="1" volume="100" pan="0" rotation="1" draggable="true" costume="0" color="80,80,80,1" pen="tip" id="8"><costumes><list struct="atomic" id="9"></list></costumes><sounds><list struct="atomic" id="10"></list></sounds><blocks></blocks><variables></variables><scripts><script x="23.076923076923077" y="33.23973911549692"><block s="receiveGo"></block><custom-block s="verbinde mit dem Raum %txt"><l>GIB DEINEN RAUMNAMEN HIER EIN</l></custom-block><block s="doDeclareVariables"><list><l>erkannte Stimmung</l></list></block><block s="doForever"><script><block s="doSetVar"><l>erkannte Stimmung</l><custom-block s="Sage Kategorie vorher für %s"><custom-block s="letzte Eingabe"></custom-block></custom-block></block><block s="doIfElse"><block s="reportEquals"><block var="erkannte Stimmung"/><l>positiv</l></block><script><custom-block s="setze Emotion auf %code"><l>smiling</l></custom-block></script><script><custom-block s="setze Emotion auf %code"><l>sad</l></custom-block></script></block></script></block></script><script x="381.9230769230769" y="171.86134247917695"><custom-block s="erstelle Klassifikator"></custom-block><custom-block s="Traininiere Klassifikator mit Liste: %l Kategorie: %s"><block s="reportNewList"><list><l>Mir geht es großartig</l><l>Alles super!</l><l>Ich fühle mich fantastisch!</l></list></block><l>positiv</l></custom-block><custom-block s="Traininiere Klassifikator mit Liste: %l Kategorie: %s"><block s="reportNewList"><list><l>Mir geht es total schlecht.</l><l>Ich fühle mich absolut miserabel</l><l>Ach frag mich nicht...</l></list></block><l>negativ</l></custom-block></script><comment x="483.8461538461538" y="7.692307692307692" w="90" collapsed="false">Hier sind die Blöcke, die für das Training relevant sind</comment><script x="387.8613424791769" y="96.4510860689206"><custom-block s="lade notwendige Funktionalität"></custom-block></script><script x="366.38461538461536" y="299.4615384615384"><custom-block s="Sage Kategorie vorher für %s"><l>Ich fühle mich großartig</l></custom-block></script><script x="345.7692307692308" y="373.17948717948724"><custom-block s="letzte Eingabe"></custom-block></script></scripts></sprite><watcher var="ws" style="slider" min="0" max="100" x="1.5656135006745444" y="1.5656135006745657" color="243,118,29" hidden="true"/><watcher var="count" style="normal" x="-2.1212637991900465" y="49.29775155357521" color="243,118,29"/></sprites></stage><hidden></hidden><headers></headers><code></code><blocks><block-definition s="test" type="reporter" category="pen"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><l></l></block></script></block-definition><block-definition s="setze Emotion auf %&apos;Emotion&apos;" type="command" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%code">smiling<options>smiling&#xD;checkright&#xD;checkleft&#xD;giggling&#xD;dubitative&#xD;sad&#xD;reallysad&#xD;bored&#xD;dubitative&#xD;chock&#xD;suspicious&#xD;satisfied&#xD;pong&#xD;killthehumans&#xD;hal9000&#xD;recorder</options></input></inputs><script><custom-block s="send %s to websocket %obj"><block var="Emotion"/><block var="ws"/></custom-block></script></block-definition><block-definition s="verbinde mit dem Raum %&apos;room&apos;" type="command" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doSetVar"><l>ws</l><custom-block s="open websocket to ws:// %txt %s"><l>localhost:8080/</l><block var="room"/></custom-block></block></script></block-definition><block-definition s="open websocket to ws:// %&apos;url&apos; %&apos;room&apos;" type="reporter" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%txt">localhost:8080/</input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>url</l><l>room</l></list><l>if (window.ws &amp;&amp; window.ws.readyState == 1){&#xD;  window.ws.close()&#xD;window.ws = undefined&#xD;}&#xD;if (window.ws !== undefined){&#xD;return}&#xD;&#xD;window.ws = new WebSocket(&apos;ws://&apos; + url + room);&#xD;&#xD;ws.addEventListener(&apos;message&apos;, function (event) {&#xD;    console.log(&apos;Message from server &apos;, event.data);&#xD;window.lastInput = event.data.split("heard:")[1]&#xD;});&#xD;</l></block><list><block var="url"/><block var="room"/></list></block></block></script></block-definition><block-definition s="send %&apos;emotion&apos; to websocket %&apos;ws&apos;" type="command" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%obj"></input></inputs><script><block s="doRun"><block s="evaluate"><block var="ws"/><list><l>send</l></list></block><list><block var="emotion"/></list></block></script></block-definition><block-definition s="test2" type="command" category="control"><header></header><code></code><translations></translations><inputs></inputs></block-definition><block-definition s="lade notwendige Funktionalität" type="command" category="operators"><comment x="0" y="0" w="90" collapsed="false">https://github.com/andreekeberg/ml-classify-text-js MIT Licence&#xD;</comment><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>class Model {&#xD;    constructor(config = {}) {&#xD;        if (!(config instanceof Object) || config.constructor !== Object) {&#xD;            throw new Error("config must be an object literal");&#xD;        }&#xD;&#xD;        config = {&#xD;            nGramMin: 1,&#xD;            nGramMax: 1,&#xD;            vocabulary: [],&#xD;            data: {},&#xD;            ...config,&#xD;        };&#xD;&#xD;        if (config.nGramMin !== parseInt(config.nGramMin, 10)) {&#xD;            throw new Error("Config value nGramMin must be an integer");&#xD;        }&#xD;&#xD;        if (config.nGramMax !== parseInt(config.nGramMax, 10)) {&#xD;            throw new Error("Config value nGramMax must be an integer");&#xD;        }&#xD;&#xD;        if (config.nGramMin &lt; 1) {&#xD;            throw new Error("Config value nGramMin must be at least 1");&#xD;        }&#xD;&#xD;        if (config.nGramMax &lt; 1) {&#xD;            throw new Error("Config value nGramMax must be at least 1");&#xD;        }&#xD;&#xD;        if (config.nGramMax &lt; config.nGramMin) {&#xD;            throw new Error("Invalid nGramMin/nGramMax combination in config");&#xD;        }&#xD;&#xD;        if (&#xD;            config.vocabulary !== false &amp;&amp;&#xD;            !(config.vocabulary instanceof Vocabulary)&#xD;        ) {&#xD;            config.vocabulary = new Vocabulary(config.vocabulary);&#xD;        }&#xD;&#xD;        if (&#xD;            !(config.data instanceof Object) ||&#xD;            config.data.constructor !== Object&#xD;        ) {&#xD;            throw new Error("Config value data must be an object literal");&#xD;        }&#xD;&#xD;        this._nGramMin = config.nGramMin;&#xD;        this._nGramMax = config.nGramMax;&#xD;        this._vocabulary = config.vocabulary;&#xD;        this._data = { ...config.data };&#xD;    }&#xD;&#xD;    /**&#xD;     * Minimum n-gram size&#xD;     *&#xD;     * @type {int}&#xD;     */&#xD;    get nGramMin() {&#xD;        return this._nGramMin;&#xD;    }&#xD;&#xD;    set nGramMin(size) {&#xD;        if (size !== parseInt(size, 10)) {&#xD;            throw new Error("nGramMin must be an integer");&#xD;        }&#xD;&#xD;        this._nGramMin = size;&#xD;    }&#xD;&#xD;    /**&#xD;     * Maximum n-gram size&#xD;     *&#xD;     * @type {int}&#xD;     */&#xD;    get nGramMax() {&#xD;        return this._nGramMax;&#xD;    }&#xD;&#xD;    set nGramMax(size) {&#xD;        if (size !== parseInt(size, 10)) {&#xD;            throw new Error("nGramMax must be an integer");&#xD;        }&#xD;&#xD;        this._nGramMax = size;&#xD;    }&#xD;&#xD;    /**&#xD;     * Vocabulary instance&#xD;     *&#xD;     * @type {(Vocabulary|false)}&#xD;     */&#xD;    get vocabulary() {&#xD;        return this._vocabulary;&#xD;    }&#xD;&#xD;    set vocabulary(vocabulary) {&#xD;        if (vocabulary !== false &amp;&amp; !(vocabulary instanceof Vocabulary)) {&#xD;            vocabulary = new Vocabulary(vocabulary);&#xD;        }&#xD;&#xD;        this._vocabulary = vocabulary;&#xD;    }&#xD;&#xD;    /**&#xD;     * Model data&#xD;     *&#xD;     * @type {Object}&#xD;     */&#xD;    get data() {&#xD;        return this._data;&#xD;    }&#xD;&#xD;    set data(data) {&#xD;        if (!(data instanceof Object) || data.constructor !== Object) {&#xD;            throw new Error("data must be an object literal");&#xD;        }&#xD;&#xD;        this._data = { ...data };&#xD;    }&#xD;&#xD;    /**&#xD;     * Return the model in its current state an an object literal, including the&#xD;     * configured n-gram min/max values, the vocabulary as an array (if any,&#xD;     * otherwise false), and an object literal with all the training data&#xD;     *&#xD;     * @return {Object}&#xD;     */&#xD;    serialize() {&#xD;        return {&#xD;            nGramMin: this._nGramMin,&#xD;            nGramMax: this._nGramMax,&#xD;            vocabulary: Array.from(this._vocabulary.terms),&#xD;            data: this._data,&#xD;        };&#xD;    }&#xD;}&#xD;&#xD;class Prediction {&#xD;    constructor(prediction = {}) {&#xD;        if (&#xD;            !(prediction instanceof Object) ||&#xD;            prediction.constructor !== Object&#xD;        ) {&#xD;            throw new Error("prediction must be an object literal");&#xD;        }&#xD;&#xD;        prediction = {&#xD;            label: "",&#xD;            confidence: 0,&#xD;            ...prediction,&#xD;        };&#xD;&#xD;        this._label = prediction.label;&#xD;        this._confidence = prediction.confidence;&#xD;    }&#xD;&#xD;    /**&#xD;     * Label of the prediction&#xD;     *&#xD;     * @type {string}&#xD;     */&#xD;    get label() {&#xD;        return this._label;&#xD;    }&#xD;&#xD;    set label(label) {&#xD;        if (typeof label !== "string") {&#xD;            throw new Error("label must be a string");&#xD;        }&#xD;&#xD;        this._label = label;&#xD;    }&#xD;&#xD;    /**&#xD;     * Confidence of the prediction&#xD;     *&#xD;     * @type {number}&#xD;     */&#xD;    get confidence() {&#xD;        return this._confidence;&#xD;    }&#xD;&#xD;    set confidence(confidence) {&#xD;        if (typeof confidence !== "number") {&#xD;            throw new Error("confidence must be a number");&#xD;        }&#xD;&#xD;        this._confidence = confidence;&#xD;    }&#xD;}&#xD;&#xD;class Vocabulary {&#xD;    constructor(terms = []) {&#xD;        if (!(terms instanceof Array) &amp;&amp; !(terms instanceof Set)) {&#xD;            throw new Error("terms must be either an Array or a Set");&#xD;        }&#xD;&#xD;        this._terms = new Set(terms);&#xD;    }&#xD;&#xD;    /**&#xD;     * Vocabulary size&#xD;     *&#xD;     * @type {number}&#xD;     */&#xD;    get size() {&#xD;        return this._terms.size;&#xD;    }&#xD;&#xD;    /**&#xD;     * Vocabulary terms&#xD;     *&#xD;     * @type {(Array|Set)}&#xD;     */&#xD;    get terms() {&#xD;        return this._terms;&#xD;    }&#xD;&#xD;    set terms(terms) {&#xD;        if (!(terms instanceof Array) &amp;&amp; !(terms instanceof Set)) {&#xD;            throw new Error("terms must be either an Array or a Set");&#xD;        }&#xD;&#xD;        this._terms = new Set(terms);&#xD;    }&#xD;&#xD;    /**&#xD;     * Add one or more terms to the vocabulary&#xD;     *&#xD;     * @param {(string|Array|Set)} terms&#xD;     * @return {this}&#xD;     */&#xD;    add(terms) {&#xD;        if (&#xD;            typeof terms !== "string" &amp;&amp;&#xD;            !(terms instanceof Array) &amp;&amp;&#xD;            !(terms instanceof Set)&#xD;        ) {&#xD;            throw new Error("terms must be either a string, Array or Set");&#xD;        }&#xD;&#xD;        if (typeof terms === "string") {&#xD;            terms = [terms];&#xD;        } else if (terms instanceof Set) {&#xD;            terms = Array.from(terms);&#xD;        }&#xD;&#xD;        terms.forEach((term) =&gt; {&#xD;            this._terms.add(term);&#xD;        });&#xD;&#xD;        return this;&#xD;    }&#xD;&#xD;    /**&#xD;     * Remove one or more terms from the vocabulary&#xD;     *&#xD;     * @param {(string|Array|Set)} terms&#xD;     * @return {this}&#xD;     */&#xD;    remove(terms) {&#xD;        if (&#xD;            typeof terms !== "string" &amp;&amp;&#xD;            !(terms instanceof Array) &amp;&amp;&#xD;            !(terms instanceof Set)&#xD;        ) {&#xD;            throw new Error("terms must be either a string, Array or Set");&#xD;        }&#xD;&#xD;        if (typeof terms === "string") {&#xD;            terms = [terms];&#xD;        } else if (terms instanceof Set) {&#xD;            terms = Array.from(terms);&#xD;        }&#xD;&#xD;        terms.forEach((term) =&gt; {&#xD;            this._terms.delete(term);&#xD;        });&#xD;&#xD;        return this;&#xD;    }&#xD;&#xD;    /**&#xD;     * Return whether the vocabulary contains a certain term&#xD;     *&#xD;     * @param {string} term&#xD;     * @return {bool}&#xD;     */&#xD;    has(term) {&#xD;        return this._terms.has(term);&#xD;    }&#xD;&#xD;    /**&#xD;     * Return the index of a term in the vocabulary (returns -1 if not found)&#xD;     *&#xD;     * @param {string} term&#xD;     * @return {number}&#xD;     */&#xD;    indexOf(term) {&#xD;        if (!this._terms.has(term)) {&#xD;            return -1;&#xD;        }&#xD;&#xD;        return Array.from(this._terms).indexOf(term);&#xD;    }&#xD;}&#xD;&#xD;window.Classifier = class Classifier {&#xD;    constructor(model = {}) {&#xD;        if (!(model instanceof Model)) {&#xD;            model = new Model(model);&#xD;        }&#xD;&#xD;        this._model = model;&#xD;    }&#xD;&#xD;    /**&#xD;     * Model instance&#xD;     *&#xD;     * @type {Model}&#xD;     */&#xD;    get model() {&#xD;        return this._model;&#xD;    }&#xD;&#xD;    set model(model) {&#xD;        if (!(model instanceof Model)) {&#xD;            model = new Model(model);&#xD;        }&#xD;&#xD;        this._model = model;&#xD;    }&#xD;&#xD;    /**&#xD;     * Train the current model using an input string (or array of strings) and a corresponding label&#xD;     *&#xD;     * @param {(string|string[])} input - String, or an array of strings&#xD;     * @param {string} label - Corresponding label&#xD;     * @return {this}&#xD;     */&#xD;    train(input, label) {&#xD;        if (typeof input !== "string" &amp;&amp; !(input instanceof Array)) {&#xD;            throw new Error("input must be either a string or Array");&#xD;        }&#xD;&#xD;        if (typeof label !== "string") {&#xD;            throw new Error("label must be a string");&#xD;        }&#xD;&#xD;        // If input isn&apos;t an array, convert to a single item array&#xD;        if (!(input instanceof Array)) {&#xD;            input = [input];&#xD;        }&#xD;&#xD;        input.forEach((string) =&gt; {&#xD;            // Convert the string to a tokenized object&#xD;            let tokens = this.tokenize(string);&#xD;&#xD;            // If we&apos;re using a vocabulary, convert the tokens to a vector where all&#xD;            // indexes reference vocabulary terms (all terms not already in the&#xD;            // vocabulary are automatically added)&#xD;            if (this._model.vocabulary !== false) {&#xD;                tokens = this.vectorize(tokens);&#xD;            }&#xD;&#xD;            // Set up an empty entry for the label if it does not exist&#xD;            if (typeof this._model.data[label] === "undefined") {&#xD;                this._model.data[label] = {};&#xD;            }&#xD;&#xD;            // Add all occurrences to our model entry&#xD;            Object.keys(tokens).forEach((index) =&gt; {&#xD;                let occurrences = tokens[index];&#xD;&#xD;                if (typeof this._model.data[label][index] === "undefined") {&#xD;                    this._model.data[label][index] = 0;&#xD;                }&#xD;&#xD;                this._model.data[label][index] += occurrences;&#xD;            });&#xD;        });&#xD;&#xD;        return this;&#xD;    }&#xD;&#xD;    /**&#xD;     * Return an array of one or more Prediction instances&#xD;     *&#xD;     * @param {string} input - Input string to make a prediction from&#xD;     * @param {int} [maxMatches=1] Maximum number of predictions to return&#xD;     * @param {float} [minimumConfidence=0.2] Minimum confidence required to include a prediction&#xD;     * @return {Array}&#xD;     */&#xD;    predict(input, maxMatches = 1, minimumConfidence = 0.2) {&#xD;        if (typeof input !== "string") {&#xD;            throw new Error("input must be a string");&#xD;        }&#xD;&#xD;        if (typeof minimumConfidence !== "number") {&#xD;            throw new Error("minimumConfidence must be a number");&#xD;        }&#xD;&#xD;        if (minimumConfidence &lt; 0) {&#xD;            throw new Error("minimumConfidence can not be lower than 0");&#xD;        }&#xD;&#xD;        if (minimumConfidence &gt; 1) {&#xD;            throw new Error("minimumConfidence can not be higher than 1");&#xD;        }&#xD;&#xD;        let tokens = this.tokenize(input);&#xD;&#xD;        if (this.vocabulary !== false) {&#xD;            tokens = this.vectorize(tokens);&#xD;        }&#xD;&#xD;        let predictions = [];&#xD;&#xD;        Object.keys(this._model.data).forEach((label) =&gt; {&#xD;            let entry = this._model.data[label];&#xD;&#xD;            let confidence = this.cosineSimilarity(tokens, entry);&#xD;&#xD;            if (confidence &gt;= minimumConfidence) {&#xD;                predictions.push(&#xD;                    new Prediction({&#xD;                        label,&#xD;                        confidence,&#xD;                    })&#xD;                );&#xD;            }&#xD;        });&#xD;&#xD;        /* istanbul ignore next */&#xD;        predictions.sort((a, b) =&gt; {&#xD;            if (a.confidence === b.confidence) {&#xD;                return 0;&#xD;            }&#xD;&#xD;            return a.confidence &gt; b.confidence ? -1 : 1;&#xD;        });&#xD;&#xD;        return predictions.slice(0, Math.min(predictions.length, maxMatches));&#xD;    }&#xD;&#xD;    /**&#xD;     * Split a string into an array of lowercase words, with all non-letter characters removed&#xD;     *&#xD;     * @param {string} input&#xD;     * @return {Array}&#xD;     */&#xD;    splitWords(input) {&#xD;        if (typeof input !== "string") {&#xD;            throw new Error("input must be a string");&#xD;        }&#xD;&#xD;        // Remove all apostrophes and dashes to keep words intact&#xD;        input = input.replace(/&apos;|´|’|-/g, "");&#xD;&#xD;        // Lowercase all letters and replace all non-letter characters with a space&#xD;        input = input&#xD;            .toLocaleLowerCase()&#xD;            .replace(/[^a-z]/gi, " ")&#xD;            .trim();&#xD;        /*input = XRegExp.replace(&#xD;            input.toLocaleLowerCase(),&#xD;            XRegExp("\\P{L}+", "g"),&#xD;            " "&#xD;        ).trim();*/&#xD;&#xD;        return input.split(" ");&#xD;    }&#xD;&#xD;    /**&#xD;     * Create an object literal of unique tokens (n-grams) as keys, and their&#xD;     * respective occurrences as values based on an input string, or array of words&#xD;     *&#xD;     * @param {(string|string[])} input&#xD;     * @return {Object}&#xD;     */&#xD;    tokenize(input) {&#xD;        let words = typeof input === "string" ? this.splitWords(input) : input;&#xD;&#xD;        if (!(words instanceof Array)) {&#xD;            throw new Error("input must be either a string or Array");&#xD;        }&#xD;&#xD;        if (this._model.nGramMax &lt; this._model.nGramMin) {&#xD;            throw new Error(&#xD;                "Invalid nGramMin/nGramMax combination in model config"&#xD;            );&#xD;        }&#xD;&#xD;        let tokens = {};&#xD;&#xD;        // Generate a list of n-grams along with their respective occurrences&#xD;        // based on the models configured min/max values&#xD;        words.forEach((word, index) =&gt; {&#xD;            let sequence = "";&#xD;&#xD;            words.slice(index).forEach((nextWord) =&gt; {&#xD;                sequence += sequence ? " " + nextWord : nextWord;&#xD;                let tokenCount = sequence.split(" ").length;&#xD;&#xD;                if (&#xD;                    tokenCount &lt; this._model.nGramMin ||&#xD;                    tokenCount &gt; this._model.nGramMax&#xD;                ) {&#xD;                    return;&#xD;                }&#xD;&#xD;                if (typeof tokens[sequence] === "undefined") {&#xD;                    tokens[sequence] = 0;&#xD;                }&#xD;&#xD;                ++tokens[sequence];&#xD;            });&#xD;        });&#xD;&#xD;        return tokens;&#xD;    }&#xD;&#xD;    /**&#xD;     * Convert a tokenized object into a new object with all keys (terms)&#xD;     * translated to their index in the vocabulary (adding all terms to&#xD;     * the vocabulary that do not already exist)&#xD;     *&#xD;     * @param {Object} tokens&#xD;     * @return {Object}&#xD;     */&#xD;    vectorize(tokens) {&#xD;        if (!(tokens instanceof Object) || tokens.constructor !== Object) {&#xD;            throw new Error("tokens must be an object literal");&#xD;        }&#xD;&#xD;        /* istanbul ignore next */&#xD;        if (this._model.vocabulary === false) {&#xD;            throw new Error("Cannot vectorize tokens when vocabulary is false");&#xD;        }&#xD;&#xD;        let vector = {};&#xD;&#xD;        Object.keys(tokens).forEach((token) =&gt; {&#xD;            let vocabularyIndex = this._model.vocabulary.indexOf(token);&#xD;&#xD;            if (vocabularyIndex === -1) {&#xD;                this._model.vocabulary.add(token);&#xD;&#xD;                vocabularyIndex = this._model.vocabulary.size - 1;&#xD;            }&#xD;&#xD;            vector[vocabularyIndex] = tokens[token];&#xD;        });&#xD;&#xD;        return vector;&#xD;    }&#xD;&#xD;    /**&#xD;     * Return the cosine similarity between two vectors&#xD;     *&#xD;     * @param {Object} v1&#xD;     * @param {Object} v2&#xD;     * @return {float}&#xD;     */&#xD;    cosineSimilarity(v1, v2) {&#xD;        if (!(v1 instanceof Object) || v1.constructor !== Object) {&#xD;            throw new Error("v1 must be an object literal");&#xD;        }&#xD;        if (!(v2 instanceof Object) || v2.constructor !== Object) {&#xD;            throw new Error("v2 must be an object literal");&#xD;        }&#xD;&#xD;        let prod = 0.0;&#xD;        let v1Norm = 0.0;&#xD;&#xD;        Object.keys(v1).forEach((i) =&gt; {&#xD;            let xi = v1[i];&#xD;&#xD;            if (typeof v2[i] !== "undefined") {&#xD;                prod += xi * v2[i];&#xD;            }&#xD;&#xD;            v1Norm += xi * xi;&#xD;        });&#xD;&#xD;        v1Norm = Math.sqrt(v1Norm);&#xD;&#xD;        if (v1Norm === 0) {&#xD;            return 0;&#xD;        }&#xD;&#xD;        let v2Norm = 0.0;&#xD;&#xD;        Object.keys(v2).forEach((i) =&gt; {&#xD;            let xi = v2[i];&#xD;&#xD;            v2Norm += xi * xi;&#xD;        });&#xD;&#xD;        v2Norm = Math.sqrt(v2Norm);&#xD;&#xD;        if (v2Norm === 0) {&#xD;            return 0;&#xD;        }&#xD;&#xD;        return prod / (v1Norm * v2Norm);&#xD;    }&#xD;};&#xD;</l></block><list></list></block></script></block-definition><block-definition s="erstelle Klassifikator" type="command" category="sensing"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list></list><l>window.classifier = new Classifier()</l></block><list></list></block></script></block-definition><block-definition s="Traininiere Klassifikator mit Liste: %&apos;liste&apos; Kategorie: %&apos;category&apos;" type="command" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%s"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>list</l><l>category</l></list><l>window.classifier.train(list.contents, category);</l></block><list><block var="liste"/><block var="category"/></list></block></script></block-definition><block-definition s="Sage Kategorie vorher für %&apos;eingabe&apos;" type="reporter" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>a</l></list></block><block s="doSetVar"><l>a</l><block s="evaluate"><block s="reportJSFunction"><list><l>input</l></list><l>let predictions = window.classifier.predict(input)&#xD;let result = []&#xD;if (predictions.length) {&#xD;	predictions.forEach((prediction, i) =&gt; {&#xD;		console.log(`${prediction.label} (${prediction.confidence})`)&#xD;  result[i] = [prediction.label]//, prediction.confidence]&#xD;	})&#xD;} else {&#xD;	console.log(&apos;No predictions returned&apos;)&#xD;}&#xD;console.log(result)&#xD;return result</l></block><list><block var="eingabe"/></list></block></block><block s="doReport"><block var="a"/></block></script><scripts><script x="163.07692307692307" y="327.66666666666697"><block s="doRun"><block s="reifyScript"><script></script><list></list></block><list><l></l></list></block></script><script x="83.07692307692308" y="325.0000000000001"><block s="doIfElse"><l/><script></script><script></script></block></script></scripts></block-definition><block-definition s="letzte Eingabe" type="reporter" category="sensing"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return window.lastInput</l></block><list></list></block></block></script></block-definition></blocks><variables><variable name="count"><l>0</l></variable><variable name="ws"><l>message =&gt; {&#xD;  if(message == &apos;send&apos;)&#xD;    return data =&gt; ws.send(data);&#xD;  if(message == &apos;close&apos;)&#xD;    return () =&gt; ws.close();&#xD;  if(message == &apos;onmessage&apos;) {&#xD;    return proc =&gt; {&#xD;      ws.onmessage = (e) =&gt; {&#xD;        var stage = this.parentThatIsA(StageMorph) || this;&#xD;        var process = new Process();&#xD;        process.initializeFor(proc, new List([e.data]));&#xD;        stage.threads.processes.push(process);&#xD;      }&#xD;    }&#xD;  }&#xD;}</l></variable></variables></project>